# Lab 1 — `submission1.md`

## 1. Почему важно подписывать коммиты

Подписывая коммиты SSH-ключом, разработчик добавляет к каждому изменению криптографическую **гарантию подлинности**:

- ✅ **Проверяемый автор** – платформа (GitHub / GitLab) отмечает коммит как `Verified`, что даёт уверенность, что код пришёл именно от указанного автора, а не был подменён.  
- ✅ **Целостность истории** – хеш-подпись «ломается» при любом изменении, поэтому злоумышленник не сможет незаметно изменить уже принятую версию.  
- ✅ **Автоматизация процессов** – CI/CD-конвейеры могут отклонять неподписанные изменения, защищая продакшен.  
- ✅ **Профилактика репутационных рисков** – при спорных ситуациях (например, supply-chain атаки) можно доказать, кто внёс конкретный код.

> **Итого:** подписи-это цифровой эквивалент мокрой печати: небольшая дополнительная нагрузка при разработке, но существенный выигрыш в доверии и безопасности команды.

---

## 2. Краткое сравнение стратегий слияния

| Стратегия            | Как работает                                              | Плюсы                                                         | Минусы                                                     |
|----------------------|-----------------------------------------------------------|--------------------------------------------------------------|-----------------------------------------------------------|
| **Merge commit**     | Создаётся отдельный «объединяющий» коммит-узел. История всех веток сохраняется. | • Полный контекст всех веток  <br>• Простой откат через `revert`  <br>• Требует минимальных знаний Git от новичков | • История разрастается «ёлкой»  <br>• Возможны «шумовые» коммиты |
| **Squash & Merge**   | Все коммиты ветки «сплющиваются» в один перед вливанием.  | • Чистая линейная история  <br>• Легко читать `git log`      | • Теряется детальная гранулярность коммитов  <br>• Ссылки на отдельные коммиты PR обнуляются |
| **Rebase & Merge**   | Коммиты ветки переносятся (rebased) поверх `main`, будто они были сделаны после него. | • Линейная история без «Merge commit»  <br>• Сохраняется каждый атомарный коммит | • Изменяются SHA-хеши — нельзя применять к уже опубликованным веткам  <br>• Выше риск конфликтов, требуется больше Git-экспертизы |

### Почему в командной работе часто оставляют **Merge commit** по умолчанию

1. **Прозрачность:** вся параллельная работа видна целиком, полезно при расследовании багов.  
2. **Безопасное объединение:** нет переписывания истории, значит меньше риска «поломать» чужую ветку.  
3. **Совместимость с CI:** многие пайплайны строятся на событиях `merge`, их проще конфигурировать.  
4. **Низкий порог входа:** новичкам не нужно знать нюансов `rebase --interactive` или «force-push».  

Таким образом, *Merge commit* обеспечивает баланс между читаемостью, исторической точностью и безопасностью, поэтому остаётся «стандартной» стратегией в большинстве корпоративных репозиториев.
